#! /usr/bin/python
# Copyright (C) 2015 Nicira, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import atexit
import json
import netaddr
import os
import shlex
import subprocess
import sys
import uuid
from neutronclient.v2_0 import client
from flask import Flask, jsonify
from flask import request, abort

app = Flask(__name__)

AUTH_STRATEGY = ""
ENDPOINT_URL = ""
OVN_BRIDGE = "br-int"
PLUGIN_DIR = "/usr/share/docker/plugins"
PLUGIN_FILE = "/usr/share/docker/plugins/openvswitch.spec"


def call_popen(cmd):
    child = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    output = child.communicate()
    if child.returncode:
        raise RuntimeError("Fatal error executing %s" % (cmd))
    if len(output) == 0 or output[0] == None:
        output = ""
    else:
        output = output[0].strip()
    return output


def call_prog(prog, args_list):
    cmd = [prog, "-vconsole:off"] + args_list
    return call_popen(cmd)


def ovs_vsctl(args):
    return call_prog("ovs-vsctl", shlex.split(args))


def sanity_check():
    br_list = ovs_vsctl("list-br").split()
    if OVN_BRIDGE not in br_list:
        raise RuntimeError("OVN bridge is not seen")

    global AUTH_STRATEGY, ENDPOINT_URL

    AUTH_STRATEGY = "noauth"
    endpoint_ip = ovs_vsctl("get Open_vSwitch . "
                            "external_ids:ipam").strip('"')
    if not endpoint_ip:
        raise RuntimeError("ipam server's ip address not set")
    ENDPOINT_URL = "http://%s:9696/" % (endpoint_ip)
    os.environ['OS_URL'] = ENDPOINT_URL
    os.environ['OS_AUTH_STRATEGY'] = "noauth"


def cleanup():
    if os.path.isfile(PLUGIN_FILE):
        os.remove(PLUGIN_FILE)


def init():
    br_list = ovs_vsctl("list-br").split()
    if OVN_BRIDGE not in br_list:
        sys.exit("Bridge %s does not exists" % (OVN_BRIDGE))
    ovs_vsctl("set open_vswitch . external_ids:ovn-bridge=%s "
              "external_ids:ovn-encap-type=stt" % OVN_BRIDGE)

    if not os.path.isdir(PLUGIN_DIR):
        sys.exit("No docker plugin directory configured")

    try:
        fo = open(PLUGIN_FILE, "w")
        fo.write("tcp://0.0.0.0:5000")
        fo.close()
    except Exception as e:
        sys.exit("Failed to write to spec file (%s)" % (str(e)))

    atexit.register(cleanup)


# curl -i -H 'Content-Type: application/json' -X POST
# http://localhost:5000/Plugin.Activate
@app.route('/Plugin.Activate', methods=['POST'])
def plugin_activate():
    return jsonify({"Implements": ["NetworkDriver"]})


def neutron_login():
    try:
        sanity_check()
        neutron = client.Client(endpoint_url=ENDPOINT_URL,
                                auth_strategy=AUTH_STRATEGY)
    except Exception as e:
        raise RuntimeError("Failed to login into Neutron(%s)" % str(e))
    return neutron


def get_networkuuid_by_name(neutron, name):
    param = {'fields': 'id', 'name': name}
    ret = neutron.list_networks(**param)
    if len(ret['networks']) > 1:
        raise RuntimeError("More than one network for the given name")
    elif len(ret['networks']) == 0:
        network = None
    else:
        network = ret['networks'][0]['id']
    return network


# curl -i -H 'Content-Type: application/json' -X POST -d
# '{"NetworkID":"dummy-network","Options":{"subnet":"192.168.1.0/24"}}'
# http://localhost:5000/NetworkDriver.CreateNetwork
@app.route('/NetworkDriver.CreateNetwork', methods=['POST'])
def create_network():
    if not request.data:
        abort(400)

    data = json.loads(request.data)

    # NetworkID will have docker generated network uuid and it
    # becomes 'name' in a neutron network record.
    network = data.get("NetworkID", "")
    if not network:
        abort(400)

    # Docker currently does not let you specify additional arguments. But
    # plans to in the future. Till then every network is 192.168.0.0/16
    subnet = "192.168.0.0/16"
    if not subnet:
        abort(400)

    try:
        neutron = neutron_login()
    except Exception as e:
        error = "%s" % (str(e))
        return jsonify({'Err': error})

    # XXX: Currently, a create-network request from a user on one host ends
    # up being a create network request in every host.  This is a huge
    # performance penalty as now we will need to check for the existance
    # of such a network in every call. So in a 1000 node system, a create
    # network request from user will have 1000 requests to OVN's IPAM.
    try:
        if get_networkuuid_by_name(neutron, network):
            return jsonify({})
    except Exception as e:
        error = "%s" % (str(e))
        return jsonify({'Err': error})

    try:
        body = {'network': {'name': network,
                            'tenant_id': "admin",
                            'admin_state_up': True}}
        ret = neutron.create_network(body)
        network_id = ret['network']['id']
    except Exception as e:
        error = "Failed in neutron api call (%s)" % str(e)
        return jsonify({'Err': error})

    try:
        netaddr.IPNetwork(subnet)
    except Exception as e:
        neutron.delete_network(network_id)
        error = "Invalid subnet specified."
        return jsonify({'Err': error})

    try:
        body = {'subnet': {'network_id': network_id,
                           'tenant_id': "admin",
                           'ip_version': 4,
                           'cidr': subnet,
                           'name': network}}
        ret = neutron.create_subnet(body)
    except Exception as e:
        neutron.delete_network(network_id)
        error = "Failed in neutron api call (%s)" % str(e)
        return jsonify({'Err': error})

    return jsonify({})


# curl -i -H 'Content-Type: application/json' -X POST -d
# {"NetworkID":"dummy-network"}
# http://localhost:5000/NetworkDriver.DeleteNetwork
@app.route('/NetworkDriver.DeleteNetwork', methods=['POST'])
def delete_network():
    if not request.data:
        abort(400)

    data = json.loads(request.data)

    nid = data.get("NetworkID", "")
    if not nid:
        abort(400)

    try:
        neutron = neutron_login()
    except Exception as e:
        error = "%s" % (str(e))
        return jsonify({'Err': error})

    network = get_networkuuid_by_name(neutron, nid)
    if not network:
        return jsonify({})

    try:
        neutron.delete_network(network)
    except Exception as e:
        error = "Failed in neutron api call (%s)" % str(e)
        return jsonify({'Err': error})

    return jsonify({})


def get_endpointuuid_by_name(neutron, name):
    param = {'fields': 'id', 'name': name}
    ret = neutron.list_ports(**param)
    if len(ret['ports']) > 1:
        raise RuntimeError("More than one endpoint for the given name")
    elif len(ret['ports']) == 0:
        endpoint = None
    else:
        endpoint = ret['ports'][0]['id']
    return endpoint


# curl -i -H 'Content-Type: application/json' -X POST -d
# '{"NetworkID":"dummy-network","EndpointID":"dummy-endpoint","Interfaces":[],"Options":{}}'
# http://localhost:5000/NetworkDriver.CreateEndpoint
@app.route('/NetworkDriver.CreateEndpoint', methods=['POST'])
def create_endpoint():
    if not request.data:
        abort(400)

    data = json.loads(request.data)

    nid = data.get("NetworkID", "")
    if not nid:
        abort(400)

    eid = data.get("EndpointID", "")
    if not eid:
        abort(400)

    interfaces = data.get("Interfaces", "")
    if interfaces:
        # If interfaces has record, the endpoint has already
        # been created.
        return jsonify({})

    try:
        neutron = neutron_login()
    except Exception as e:
        error = "%s" % (str(e))
        return jsonify({'Err': error})

    network = get_networkuuid_by_name(neutron, nid)
    if not network:
        error = "Failed to get neutron network record for (%s)" % (nid)
        return jsonify({'Err': error})

    try:
        ret = neutron.show_network(network)
        subnet = ret['network']['subnets'][0]
        if not subnet:
            raise RuntimeError("No subnet defined for the network.")
    except Exception as e:
        error = "Could not obtain network information.\n(%s)" % (str(e))
        return jsonify({'Err': error})

    try:
        ret = neutron.show_subnet(subnet)
        gateway_ip = ret['subnet']['gateway_ip']
        cidr = ret['subnet']['cidr']
        netmask = cidr.rsplit('/', 1)[1]
        if not netmask:
            raise RuntimeError("No cidr netmask found for subnet")
    except Exception as e:
        error = "Could not obtain subnet information (%s)" % (str(e))
        return jsonify({'Err': error})

    try:
        print "creating neutron port."
        body = {'port': {'network_id': network,
                         'tenant_id': "admin",
                         'name': eid,
                         'admin_state_up': True}}

        ret = neutron.create_port(body)
        mac_address = ret['port']['mac_address']
        ip_address = "%s/%s" \
                     % (ret['port']['fixed_ips'][0]['ip_address'], netmask)

    except Exception as e:
        error = "Failed in neutron port creation call (%s)" % (str(e))
        return jsonify({'Err': error})

    return jsonify({"Interfaces": [{
                                    "ID": 0,
                                    "Address": ip_address,
                                    "AddressIPv6": None,
                                    "MacAddress": mac_address
                                    }]})


# curl -i -H 'Content-Type: application/json' -X POST -d
# '{"NetworkID":"dummy-network","EndpointID":"dummy-endpoint"}'
# http://localhost:5000/NetworkDriver.EndpointOperInfo
@app.route('/NetworkDriver.EndpointOperInfo', methods=['POST'])
def show_endpoint():
    if not request.data:
        abort(400)

    data = json.loads(request.data)

    nid = data.get("NetworkID", "")
    if not nid:
        abort(400)

    eid = data.get("EndpointID", "")
    if not eid:
        abort(400)

    try:
        neutron = neutron_login()
    except Exception as e:
        error = "%s" % (str(e))
        return jsonify({'Err': error})

    endpoint = get_endpointuuid_by_name(neutron, eid)
    if not endpoint:
        error = "Failed to get endpoint by name"
        return jsonify({'Err': error})

    try:
        ret = neutron.show_port(endpoint)
        mac_address = ret['port']['mac_address']
        ip_address = ret['port']['fixed_ips'][0]['ip_address']
    except Exception as e:
        error = "Failed to get endpoint information (%s)" % (str(e))
        return jsonify({'Err': error})

    veth_outside = eid[0:15]
    return jsonify({"Value": {"ip_address": ip_address,
                              "mac_address": mac_address,
                              "veth_outside": veth_outside
                              }})


# curl -i -H 'Content-Type: application/json' -X POST -d
# '{"NetworkID":"dummy-network","EndpointID":"dummy-endpoint"}'
# http://localhost:5000/NetworkDriver.DeleteEndpoint
@app.route('/NetworkDriver.DeleteEndpoint', methods=['POST'])
def delete_endpoint():
    if not request.data:
        abort(400)

    data = json.loads(request.data)

    nid = data.get("NetworkID", "")
    if not nid:
        abort(400)

    eid = data.get("EndpointID", "")
    if not eid:
        abort(400)

    try:
        neutron = neutron_login()
    except Exception as e:
        error = "%s" % (str(e))
        return jsonify({'Err': error})

    endpoint = get_endpointuuid_by_name(neutron, eid)
    if not endpoint:
        return jsonify({})

    try:
        neutron.delete_port(endpoint)
    except Exception as e:
        error = "Failed to delete endpoint. (%s)" % (str(e))
        return jsonify({'Err': error})

    return jsonify({})


# curl -i -H 'Content-Type: application/json' -X POST -d
# '{u'NetworkID': u'dummy-network', u'SandboxKey': u'sandbox-key', \
#   u'Options': {u'foo': u'fooValue'}, u'EndpointID': u'dummy-endpoint'}'
# http://localhost:5000/NetworkDriver.Join
@app.route('/NetworkDriver.Join', methods=['POST'])
def network_join():
    if not request.data:
        abort(400)

    data = json.loads(request.data)

    nid = data.get("NetworkID", "")
    if not nid:
        abort(400)

    eid = data.get("EndpointID", "")
    if not eid:
        abort(400)

    sboxkey = data.get("SandboxKey", "")
    if not sboxkey:
        abort(400)

    # sboxkey is of the form: /var/run/docker/netns/CONTAINER_ID
    vm_id = sboxkey.rsplit('/')[-1]

    try:
        neutron = neutron_login()
    except Exception as e:
        error = "%s" % (str(e))
        return jsonify({'Err': error})

    endpoint = get_endpointuuid_by_name(neutron, eid)
    if not endpoint:
        error = "Failed to get endpoint by name"
        return jsonify({'Err': error})

    try:
        ret = neutron.show_port(endpoint)
        mac_address = ret['port']['mac_address']
    except Exception as e:
        error = "Failed to get endpoint information (%s)" % (str(e))
        return jsonify({'Err': error})

    veth_outside = eid[0:15]
    veth_inside = eid[0:13] + "_c"
    command = "ip link add %s type veth peer name %s" \
              % (veth_inside, veth_outside)
    try:
        call_popen(shlex.split(command))
    except Exception as e:
        error = "Failed to create veth pair (%s)" % (str(e))
        return jsonify({'Err': error})

    command = "ip link set dev %s address %s" \
              % (veth_inside, mac_address)

    try:
        call_popen(shlex.split(command))
    except Exception as e:
        error = "Failed to set veth mac address (%s)" % (str(e))
        return jsonify({'Err': error})

    try:
        ovs_vsctl("add-port %s %s" % (OVN_BRIDGE, veth_outside))
        ovs_vsctl("set interface %s external_ids:attached-mac=%s "
                  "external_ids:iface-id=%s "
                  "external_ids:vm-id=%s "
                  "external_ids:iface-status=%s "
                  % (veth_outside, mac_address,
                     endpoint, vm_id, "active"))
    except Exception as e:
        error = "Failed to create a port (%s)" % (str(e))
        return jsonify({'Err': error})

    return jsonify({"InterfaceNames": [{
                                        "SrcName": veth_inside,
                                        "DstPrefix": "eth"
                                       }],
                    "Gateway": "",
                    "GatewayIPv6": "",
                    "HostsPath": "",
                    "ResolvConfPath": ""})


# curl -i -H 'Content-Type: application/json' -X POST -d
# '{"NetworkID":"dummy-network","EndpointID":"dummy-endpoint"}'
# http://localhost:5000/NetworkDriver.Leave
@app.route('/NetworkDriver.Leave', methods=['POST'])
def network_leave():
    if not request.data:
        abort(400)

    data = json.loads(request.data)

    nid = data.get("NetworkID", "")
    if not nid:
        abort(400)

    eid = data.get("EndpointID", "")
    if not eid:
        abort(400)

    veth_outside = eid[0:15]
    command = "ip link delete %s" % (veth_outside)
    try:
        call_popen(shlex.split(command))
    except Exception as e:
        error = "Failed to delete veth pair (%s)" % (str(e))
        return jsonify({'Err': error})

    try:
        ovs_vsctl("--if-exists del-port %s" % (veth_outside))
    except Exception as e:
        error = "Failed to delete port (%s)" % (str(e))
        return jsonify({'Err': error})

    return jsonify({})

if __name__ == '__main__':
    init()
    # app.run(host='0.0.0.0')
    app.run(debug=True)
